/* c_m3d_g_sph.cpp autogenerated by split.py v0.3 at 2021-01-01 14:53:31.074880 */

#include "SComponent/c_m3d_g_sph.h"
#include "SComponent/c_m3d.h"

extern "C" {
void cM3d_Cross_CylSph__FPC8cM3dGCylPC8cM3dGSphP3VecPf(void);
void cM3d_Cross_SphSph__FPC8cM3dGSphPC8cM3dGSphP3Vec(void);
void SetC__8cM3dGSphFRC4cXyz(void);
void SetR__8cM3dGSphFf(void);
}

// SetC__8cM3dGSphFRC4cXyz
void cM3dGSph::SetC(const cXyz& pCenter) {
    mCenter = pCenter;
}

// Set__8cM3dGSphFRC4cXyzf
void cM3dGSph::Set(const cXyz& pCenter, f32 pRadius) {
    this->SetC(pCenter);
    this->SetR(pRadius);
}

// Set__8cM3dGSphFRC9cM3dGSphS
void cM3dGSph::Set(const cM3dGSphS& pOther) {
    this->SetC(cXyz(pOther.mCenter));
    this->SetR(pOther.mRadius);
}

// SetR__8cM3dGSphFf
void cM3dGSph::SetR(f32 pRadius) {
    mRadius = pRadius;
}

// cross__8cM3dGSphCFPC8cM3dGSphP4cXyz
bool cM3dGSph::cross(const cM3dGSph* pOther, cXyz* pOut) const {
    return cM3d_Cross_SphSph(pOther, this, pOut);
}

// cross__8cM3dGSphCFPC8cM3dGCylP4cXyz
bool cM3dGSph::cross(const cM3dGCyl* pCylinder, cXyz* pOut) const {
    f32 f;
    return cM3d_Cross_CylSph(pCylinder, this, pOut, &f);
}

// GetMinMaxCube__8cM3dGSphCFR4cXyzR4cXyz
void cM3dGSph::GetMinMaxCube(cXyz& pMin, cXyz& pMax) const {
    pMin.x = mCenter.x - mRadius;
    pMin.y = mCenter.y - mRadius;
    pMin.z = mCenter.z - mRadius;
    pMax.x = mCenter.x + mRadius;
    pMax.y = mCenter.y + mRadius;
    pMax.z = mCenter.z + mRadius;
}
