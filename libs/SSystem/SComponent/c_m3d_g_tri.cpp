/* c_m3d_g_tri.cpp autogenerated by split.py v0.3 at 2021-01-01 14:55:53.593962 */

#include "SComponent/c_m3d_g_tri.h"
#include "SComponent/c_m3d.h"

extern "C" {
void cM3d_CalcPla__FPC3VecPC3VecPC3VecP3VecPf(void);
void cM3d_Cross_CylTri__FPC8cM3dGCylPC8cM3dGTriP3Vec(void);
void Set__8cM3dGPlaFPC8cM3dGPla(void);
void SetupNP__8cM3dGPlaFRC3VecRC3Vec(void);
}

// cross__8cM3dGTriCFPC8cM3dGCylP3Vec
bool cM3dGTri::cross(const cM3dGCyl* pCylinder, Vec* out) const {
    return cM3d_Cross_CylTri(pCylinder, this, out);
}

// setPos__8cM3dGTriFPC3VecPC3VecPC3Vec
void cM3dGTri::setPos(const Vec* pA, const Vec* pB, const Vec* pC) {
    mA = *pA;
    mB = *pB;
    mC = *pC;
    cM3d_CalcPla(&mA, &mB, &mC, &mPlane.mNormal, &mPlane.mD);
}

// setBg__8cM3dGTriFPC3VecPC3VecPC3VecPC8cM3dGPla
void cM3dGTri::setBg(const Vec* pA, const Vec* pB, const Vec* pC, const cM3dGPla* pPlane) {
    mA = *pA;
    mB = *pB;
    mC = *pC;
    mPlane.Set(pPlane);
}

// set__8cM3dGTriFPC3VecPC3VecPC3VecPC3Vec
void cM3dGTri::set(const Vec* pA, const Vec* pB, const Vec* pC, const Vec* pNormal) {
    mA = *pA;
    mB = *pB;
    mC = *pC;
    mPlane.SetupNP(*pNormal, *pA);
}
